# Процесс ревью

Основная задача ревью в моём представлении − это выявить проблемы в коде, которые _не могут_ в должной мере (и вряд ли хоть сколь-нибудь скоро смогут) выявить роботы, среди которых в нашем распоряжении всяческие линтеры, форматтеры, статические анализаторы кода и погонщики различных тестов: функциональных, интеграционных, нагрузочных, регрессионных, миграционных.

Подобные проблемы довольно _субъективны_, они негативно влияют на субъективные _метрики_, собственно как раз поэтому они слабо поддаются автоматическому анализу.

## Простота восприятия

Основная интегральная метрика на мой взгляд − это _простота восприятия_ кода. Это то, насколько просто гипотетическому неискушённому залётному разработчику, который никогда не имел дело с системой, будет погрузиться в код и понять, что там происходит.<sup>(спойлер: ответ почти всегда «сложно», но по крайней это можно оценить)</sup>

Стоит отметить, что любая система в процессе эволюции, появления новых функций и уточнения существующих _усложняется_, репозитории с кодом в этом смысле не исключение. Это в общем случае означает, что простота восприятия при этом не может не ухудшаться. Измерить эту метрику в абсолютных значениях довольно сложно, но в процессе ревью (как итеративного процесса) автор и ты (ревьювер) можете придти к консенсусу о том, что по вашей оценке простота восприятия почти не пострадала или по крайней мере не ухудшилась сверх меры, что и является поводом для того, чтобы ты выдал аппрув.

Если рассуждать в рамках концепции разделения сложности на [_essential_ и _accidental_ complexity][^1][^2], то выдача аппрува по сути означает то, что автор смог минимизировать появление новой accidental complexity.

Само собой для полного устранения accidental complexity с сохранением остальных важных для нас характеристик (например, низкие требования к вычислительным ресурсам) может понадобиться бесконечное количество итераций. Мы неизбежно ограничены временем, и ты должен это осознавать.

Теперь конкретные рекомендации, которые как мне кажется могут пригодиться в процессе ревью для контроля за этой метрикой.

1. Не привносим ли мы сущности и абстракции без явной необходимости?

    Если да, то это чистая accidental complexity. В общем, [Keep It Simple Stupid][3]. Следи за тем, чтобы у модулей и сервисов должны были простые незамысловатые интерфейсы. Чтобы у функций не было особенного, неочевидного поведения в каких-то краевых случаях.
    
    Стоит правда отметить, что необходимость, вызванная нашими ожиданиями о развитии системы и расширении требований, тоже на мой взгляд вполне себе необходимость, просто тебе стоит быть более требовательным к аргументам в пользу её появления.

1. Не появляется ли у сущностей абсурдных или противоречивых состояний?

    А, соответственно, у интерфейсов − абсурдных или противоречивых входных параметров.
    
    Близкий нам пример: у инвойса можно указать как сумму, так и корзину товаров, каждый из которых имеет стоимость. При этом если мы позволяем указать одновременно и то, и другое, то нам неизбежно придётся разбираться с ситуациями, когда одно другому не соответствует. А если мы по какой-то глупой причине об этом забудем, то мы рискуем тем, что в системе навсегда (в худшем случае) останется сущность в неконсистентном состоянии. Лучше такого избегать.

1. Не становится ли существующая абстракция слишком перегруженной?

    Тогда это повод разделить её на 2 абстракции. Или 3 абстракции. Возможно даже окажется, что другие абстракции в репозитории перегружены таким же образом, тогда мы даже смогли бы увеличить простоту восприятия подобным разделением. Частым признаком перегруженности являются километровые имена функций и аргументов. Если ты видишь километровые имена в коде, задайся этим вопросом.

    Вообще, этим вопросом (как кстати и предыдущим) тебе не помешает задаваться в разрезе не только конкретного PR и конкретного репозитория / проекта / сервиса, но и в разрезе системы в целом. Правда тогда результатом будет не докоп к PR, а задача или эпик в бэклоге.

1. Не размазывается ли отвественность между фрагментами системы?

    В нашем случае это могут быть фрагменты самых разных масштабов: функции, модули, библиотеки, приложения и сервисы. В случае репозиториев с кодов это подобное случается гораздо чаще, поэтому тебе стоит за этим следить. Часто абстракции из одного модуля «протекают» в модуль более высокого уровня, и приносят за собой часть той сложности, которую они пытаются при этом скрыть. Это часто приводит ещё и к тому, что подобные тесно связанные абстракции нельзя протестировать независимо друг от друга, а это в свою очередь приводит к усложнению тестового кода и росту количества состояний системы, которое нам приходится тестировать (даже если мы этого не хотим).
    
    Это очевидная accidental complexity, которую мы должны минимизировать: следить за тем, чтобы границы ответственности модулей / библиотек / сервисов были чётко определены. А как следствие их интерфейсы − минимальны и самодостаточны, легко поддающиеся тестированию в отрыве от других абстракций.

1. Все ли вещи называются своими именами?

    Для неискушённого разработчика любое новое имя равноценно появлению новой сущности. А любое неочевидное название равноценно наличию скрытой за этой неочевидностью сложности. Нужно стараться, чтобы одни и те же вещи в рамках системы в целом назывались одними и теми же именами, тогда одного имени достаточно, чтобы понять о какой сущности идёт речь.

    Ещё внимательнее нужно следить за тем, чтобы одно и то же имя было не слишком перегружено, не скрывало за собой несколько разных или даже просто _не совсем одинаковых_ сущностей.

1. Не привносим ли мы излишние «движущиеся части»?

    Например, добавление слоя кэширования там, где мы и так не слишком страдаем в его отсутствии от высоких таймингов или излишнего использования ресурсов. Кэш − это «движущаяся часть» со своим состоянием, и его появление автоматически заставляет нас думать о том, о чём мы раньше не задумывались. Что если кэш устарел? Что если кэш устарел на одном инстансе сервиса, но не устарел на другом? И так далее.

    Надо понимать, что в общем случае количество состояний системы равно произведению количества состояний каждой из подобных движущихся частей. Каждая новая движущаяся часть _многократно_ усложняет сложность тестирования, ведь идеальные тесты − это такие, которые проверяют корректность поведения системы в _каждом_ из возможных состояний.

[^1]: http://curtclifton.net/papers/MoseleyMarks06a.pdf
[^2]: https://www.infoq.com/presentations/Simple-Made-Easy

[3]: https://en.wikipedia.org/wiki/KISS_principle
